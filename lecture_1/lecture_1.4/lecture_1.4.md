
# Базовые типы

## Вывод типа выражения

Haskell - типизированный язык со строгой статической системой типов. Строгая типизация означает отсутствие неявного приведения типов. При статической типизации проверка типов происходит во время компиляции.

Haskell умеет выводить типы выражений самостоятельно.

Можно изучать типы выражений с помощью интерпретатора и команды `:type` или сокращенно `:t`:
```
Prelude> :t 1
1 :: Num p => p
Prelude> :t True
True :: Bool
Prelude> :t False
False :: Bool
Prelude> :t 'a'
'a' :: Char
Prelude> :t "hello"
"hello" :: [Char]
```

## Числовые типы и числовые литералы

Числовые типы Haskell:
* Int - целые ограниченного размера
* Integer - целые произвольного размера
* Float - числа с плавающей точкой одинарной точности
* Double - числа с плавающей точкой двойной точности

Все целые принадлежат к классу типов `Num`. Все числа с плавающей точкой - к классу типов `Fractional`. Понятие класса типов будет введено далее. Сейчас стоит лишь сказать, что класс типов - это общий интерфейс типов для задания для них одних и тех же операций.

```
Prelude> :t 1
1 :: Num p => p
Prelude> :t 3.14
3.14 :: Fractional p => p
```
1 является представителем класса типов `Num`.

Можно явно задать тип выражения:
```
Prelude> let x = 3 :: Int
Prelude> :t x
x :: Int
```

Автовывод типов при использовании в выражениях:
```
Prelude> let y = 10 :: Double
Prelude> let z = y + 20
Prelude> :t z
z :: Double
```
z является Double т.к. y - Double

Еще пример:
```
Prelude> let a = 4
Prelude> let b = 5
Prelude> :t a
a :: Num p => p
Prelude> let c = a + b
Prelude> :t c
c :: Num a => a
```

Пример строгости типов:
```
Prelude> let e = y + x

<interactive>:20:13: error:
    • Couldn't match expected type ‘Double’ with actual type ‘Int’
    • In the second argument of ‘(+)’, namely ‘x’
      In the expression: y + x
      In an equation for ‘e’: e = y + x
```
Здесь используются раннее введенные `y :: Double` и `x :: Int`.

Тип Integer может содержать константы произвольной длины:
```
Prelude> 999999999999999999999999999999999999999999 :: Integer
999999999999999999999999999999999999999999
```

## Тест 1

Какие из следующих выражений типизированы верно, то есть не приводят к ошибкам типа?

- [ ] (3 :: Int) + (5 :: Integer)
- [ ] (3.0 :: Integer) + (5 :: Integer)
- [ ] (3 :: Double) + (5 :: Float)
- [x] (3 :: Integer) + (5 :: Integer)
- [x] (3.2 :: Double) + (5 :: Double)

Haskell - строго типизированный язык, поэтому можно складывать только константы одного и того же типа.

## Тип функции

Для описания типов функций используют оператор `->`. Он бинарный и **правоассоциативный**. Левый операнд - тип аргумента, правый - тип возвращаемого значения.

Исследуем функцию `not`:
```
Prelude> :t not
not :: Bool -> Bool
```
Для функций двух аргументов:
```
Prelude> (&&) True False
False
Prelude> :t (&&)
(&&) :: Bool -> Bool -> Bool
```
Из-за частичного применения функций опять же рассматриваем функцию двух аргументов как функцию одного аргумента:
```
Bool -> Bool -> Bool
Bool -> (Bool -> Bool)
```
Скобки как раз показывают что это правоассоциативный оператор.

## Задача 1

Вспомним функцию discount, которая возвращала итоговую сумму покупки с возможной скидкой. В качестве параметров ей передавались сумма без скидки sum, процент скидки proc, причем скидка начислялась, если переданная сумма превышает порог limit. Все эти параметры, как и возвращаемое значение, можно хранить в типе Double. (Здесь следует отметить, что в реальных финансовых приложениях использовать тип с плавающей точкой для хранения подобной информации не рекомендуется.) Тип функции можно задать в файле исходного кода вместе с ее определением:
```
discount :: Double -> Double -> Double -> Double
discount limit proc sum = if sum >= limit then sum * (100 - proc) / 100 else sum
```
Отметим, что объявление типа необязательно, хотя часто рекомендуется в качестве документации. Его обычно располагают перед определением функции, хотя это объявление верхнего уровня можно расположить в любом месте файла с исходным кодом.

Запишите тип функции standardDiscount, определенной как частичное применение функции discount:
```
standardDiscount :: ?
standardDiscount = discount 1000 5 
```

**Ответ:**
```
standardDiscount :: Double -> Double
standardDiscount = discount 1000 5 
```

## Импорт модулей и справочная система

Для импорта модулей:
```
import Data.Complex
import Data.Char
```
Аналогичным образом импортируются модули в интерпретаторе.

Справка по модулям, да и по языку в целом находится [здесь](https://www.haskell.org/hoogle/)

## Задача 2

Воспользовавшись справочной системой Hoogle, найдите имя функции типа Char -> Char, переводящей символ в нижний регистр.

**Ответ:** toLower

## Задача 3

Реализуйте функцию twoDigits2Int, которая принимает два символа и возвращает число, составленное из этих символов, если оба символа числовые, и 100 в противном случае. (Первый символ рассматривается как количество десятков, второй — единиц.)
```
GHCi> twoDigits2Int '4' '2'
42
```

**Ответ:**
```
import Data.Char
twoDigits2Int :: Char -> Char -> Int
twoDigits2Int x y =
  if isDigit x && isDigit y
    then digitToInt x * 10 + digitToInt y
    else 100
```

Код задачи можно загрузить [из файла](./task_1.4.3.hs).

## Тип кортежа

Кортеж - упорядоченный набор элементов фиксированной длины. Каждый из элементов может иметь любой тип.

Задание кортежа:
```
Prelude> (2, True)
(2,True)
```

Функции для кортежей из 2х элементов:
```
Prelude> fst (2, True)
2
Prelude> snd (2, True)
True
```

Одноэлементных кортежей не бывает, но бывают пустые кортежи:
```
Prelude> :t (10)
(10) :: Num p => p
Prelude> :t ()
() :: ()
```

## Задача 4

Будем задавать точки на плоскости парами типа (Double, Double). Реализуйте функцию dist, которая возвращает расстояние между двумя точками, передаваемыми ей в качестве аргументов.

**Ответ:**
```
dist :: (Double, Double) -> (Double, Double) -> Double
dist p1 p2 = sqrt ((fst p1 - fst p2) ^ 2 + (snd p1 - snd p2) ^ 2)
```

Код задачи можно загрузить [из файла](./task_1.4.4.hs).

## Тип списка

Списки, как и кортежи, являются контейнерными типами. Списки **гомогенны**, а кортежи **гетерогенны**. Это значит, что все элементы списка должны принадлежать к одному типу. В отличие от кортежей, которые могут содержать значения разных типов. Длина списка не фиксирована.

Задание списка:
```
*Main> [1,2,3,4,5]
[1,2,3,4,5]
*Main> :t [1,2,3,4,5]
[1,2,3,4,5] :: Num a => [a]
*Main> :t [False, True]
[False, True] :: [Bool]
```

Список типа `Char` - ни что иное как строка, есть синоним типу `[Char]` - `String`. Такие записи эквивалентны:
```
*Main> ['A', 'B']
"AB"
*Main> "AB"
"AB"
*Main> :t ['A', 'B']
['A', 'B'] :: [Char]
*Main> :t "AB"
"AB" :: [Char]
*Main> "AB"::String
"AB"
*Main> "AB"::[Char]
"AB"
```

## Базовые операции над списками

Добавление элемента в голову списка. Оператор `:`:
```
*Main> 'H' : "ello"
"Hello"
*Main> 1 : [2,3,4,5]
[1,2,3,4,5]
```

Конкатенация списков. Оператор `++`:
```
*Main> "Hello" ++ " Vlad"
"Hello Vlad"
*Main> [1,2,3] ++ [4,5,6]
[1,2,3,4,5,6]
```

## Тест 2

Операторы (:) и (++) имеют одинаковую ассоциативность и приоритет. Укажите их. (Воспользуйтесь командой интерпретатора GHCi :info).

```
*Main> :info (:)
data [] a = ... | a : [a]       -- Defined in ‘GHC.Types’
infixr 5 :
*Main> :info (++)
(++) :: [a] -> [a] -> [a]       -- Defined in ‘GHC.Base’
infixr 5 ++
```

Ответ: `infixr 5`

## Тест 3

Не используя GHCi, выберите выражения, проходящие проверку типов.


- [ ] [1,2] : 3 ++ [4,5,6]
- [ ] [1,2] ++ [3,4,5] : 6
- [x] (:) 1 ((++) [2,3] [4,5,6])
- [ ] (:) 1 (++) [2,3] [4,5,6]
- [x] [1,2] ++ 3 : [4,5,6]
- [ ] (++) [1,2] 3 : [4,5,6]
- [x] [1,2] ++ (:) 3 [4,5,6]
- [x] 1 : [2,3] ++ [4,5,6]

При использовании оператора как функции приоритет повышается (становится 10) и применение становится левоассоциативным.