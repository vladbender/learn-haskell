
# Рекурсия

## Рекурсивное определение функции

В императивных языках для повторения вычислений используются циклы. В функциональных языках они отсутствуют т.к. отсутствует изменение переменных. Поэтому нельзя отличить одну итерацию цикла от другой. Вместо этого используется рекурсия.

Определение функции называется рекурсивным, если в правой части описания функции присутствует вызов самой функции.

Пример вычисления факториала:
```haskell
factorial n = if n == 0 then 1 else n * factorial (n - 1)
```
Требования к функции, чтобы ее вычисление не зациклилось:
1) Вызовы функции в правой части должны осуществляться на параметрах, отличных от переданных в функцию
1) Рекурсивные вызовы должны где то прерываться. Должно быть терминирующее условие. В какой то из ветвей выполнения функции должно возвращаться значение, а не осуществляться рекурсивный вызов.

Вычисление рекурсивной функции происходит так же как и вычисление выражения. С помощью редукции:
```haskell
factorial 2
  ~> if 2 == 0 then 1 else 2 * factorial 1
  ~> 2 * factorial 1
  ~> 2 * (if 1 == 0 then 1 else 1 * factorial 0)
  ~> 2 * 1 * factorial 0
  ~> 2 * factorial 0
  ~> 2 * (if 0 == 0 then 1 else 1 * factorial (-1))
  ~> 2 * 1
  ~> 2
```

## Сопоставление с образцом

Использование `if then else` не всегда удобно. В Haskell существует **сопоставление с образцом**. Идея заключается в том, что мы описываем функцию не с помощью одного уравнения, а с помощью нескольких уравнений, каждое из которых описывает одну из возможных ветвей программы.

Пример вычисления факториала в таком подходе:
```haskell
factorial 0 = 1
factorial n = n * factorial (n - 1)
```
Тут в первой строчке находится образец возможного значения параметра функции и результата при этом параметре. При передаче параметра в вызываемую функцию, он будет последовательно сверху вниз сравниваться с имеющимися образцами. Самый последний вариант содержит не значение, а переменную - это **неопровержимый образец**. Сопоставление с ним всегда удачно.

## Задача 1

Определите функцию, вычисляющую двойной факториал, то есть произведение натуральных чисел, не превосходящих заданного числа и имеющих ту же четность. Например: 7!! = 7 * 5 * 3 * 1, 8!! = 8 * 6 * 4 * 2. Предполагается, что аргумент функции может принимать только неотрицательные значения.

```haskell
doubleFact :: Integer -> Integer
doubleFact 0 = 0
doubleFact 1 = 1
doubleFact 2 = 2
doubleFact n = n * doubleFact (n - 2)
```

Код задачи можно загрузить [из файла](./task_1.5.1.hs).

## Незавершающиеся программы и ошибки

Если вызвать `factorial (-1)`, то программа зациклится. Для того, чтобы определить функцию на тех аргументах, на которых она корректно работать не может, есть две функции: `error` и `undefined`:

```haskell
*Main> error "asdas"
*** Exception: asdas
CallStack (from HasCallStack):
  error, called at <interactive>:6:1 in interactive:Ghci6
*Main> undefined
*** Exception: Prelude.undefined
CallStack (from HasCallStack):
  error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err
  undefined, called at <interactive>:7:1 in interactive:Ghci6
```

`error` прерывает выполнение программы и печатает в диагностический поток сообщение об ошибке.

`undefined` прерывает выполнение программы.

Можно переписать факториал как:
```haskell
factorial 0 = 1
factorial n = if n < 0 then error "arg must be >= 0" else n * factorial (n - 1)
```
 
Функция `undefined` подходит в качестве выражения любого типа. Принято её использовать для того, чтобы помечать еще ненаписанные части программы. Либо в тех местах, до которых исполнение гарантировано не дойдет.

Функцию `error` используют в тех случаях, когда исполнение программы в этой точке возможно, но ошибочно.

## Охранные выражения

Иногда неудобно сопоставлять с образцом т.к. условие может быть сложным.

Для этого используются **охранные выражения** или **guards**.

Описываются они так:
```haskell
factorial 0 = 1
factorial n | n < 0 = error "arg must be >= 0"
            | n > 0 = n * factorial (n - 1)
```
Охранные выражения должны возвращать булевый тип.
Если не произошло сопоставления ни с одним из охранных выражений и ни с одним из образцов, то будет ошибка.

Можно переписать пример полностью на охранных выражениях:
```haskell
factorial n | n == 0 = 1
            | n > 0 = n * factorial (n - 1)
            | otherwise = error "arg must be >= 0"
```
При этом `otherwise` означает выполнение в тех случаях, когда ни одно из охранных выражений не вернуло истину.

## Задача 2

В последнем примере предыдущего шага в охранном выражении использовался идентификатор otherwise. Это не ключевое слово, а константа, определенная для удобства в стандартной библиотеке:
```haskell
otherwise = ?
```
Как вы думаете, какова правая часть её определения?

**Ответ:** `True`

## Задача 3

Последовательность чисел Фибоначчи 0,1,1,2,3,5,8,13,21,... легко определить рекурсивно, задав два первых терминирующих значения и определив любое последующее как сумму двух непосредственно предыдущих:
```
F_0 = 0
F_1 = 1
F_n = F_{n - 1} + F_{n - 2}
```
На Haskell данное определение задаётся следующей функцией:
```haskell
fibonacci 0 = 0
fibonacci 1 = 1
fibonacci n = fibonacci (n - 1) + fibonacci (n - 2)
```
Эта функция определена лишь для неотрицательных чисел. Однако, из данного выше определения можно вывести формулу для вычисления чисел Фибоначчи при отрицательных индексах, при этом последовательность будет следующей:
```
F_{-1} = 1, F_{-2} = -1, ..., F_{-10} = -55
```
Измените определение функции fibonacci так, чтобы она была определена для всех целых чисел и порождала при отрицательных аргументах указанную последовательность.

```haskell
fibonacci :: Integer -> Integer
fibonacci n = undefined
```

**Ответ:**
```haskell
fibonacci 0 = 0
fibonacci 1 = 1
fibonacci n | n > 0 = fibonacci (n - 1) + fibonacci (n - 2)
            | n < 0 = fibonacci (n + 2) - fibonacci (n + 1)
```

Код задачи можно загрузить [из файла](./task_1.5.3.hs).

## Рекурсия с явным аккумулятором

Мы можем реализовать функцию, которая работает как цикл, используя дополнительный параметр:
```haskell
factorial n | n >= 0    = helper 1 n
            | otherwise = error "arg must be >= 0"
helper acc 0 = acc
helper acc n = helper (acc * n) (n - 1)
```
Здесь мы используем доп функцию helper, у которой первая переменная является аккумулятором, который накапливает значение.

Очень часто подобная реализация повышает эффективность подобных функций. Дальше идет какое то рассуждение о полиноминальной и линейной ассимптотике, но я его не понял.

## Задача 4

Реализация функции для вычисления числа Фибоначчи, основанная на прямом рекурсивном определении, крайне неэффективна - количество вызовов функции растет экспоненциально с ростом значения аргумента. GHCi позволяет отслеживать использование памяти и затраты времени на вычисление выражения, для этого следует выполнить команду :set +s:
```haskell
GHCi> :set +s
GHCi> fibonacci 30
832040
(8.36 secs, 298293400 bytes)
```
С помощью механизма аккумуляторов попробуйте написать более эффективную реализацию, имеющую линейную сложность (по числу рекурсивных вызовов). Как и в предыдущем задании, функция должна быть определена для всех целых чисел.

**Ответ:**
```haskell
fibonacci n | n == 0 = 0
            | n == 1 = 1
            | n > 1 = pos 0 1 n
            | n < 0 = neg 0 1 n

pos prev value 1 = value
pos prev value n = pos (value) (prev + value) (n - 1)

neg prev value (-1) = value
neg prev value n = neg (value) (prev - value) (n + 1)
```

Код задачи можно загрузить [из файла](./task_1.5.4.hs).

P.S. Только решив задачу, понял что можно домножать результат вычисления функции Фибоначчи на (-1) в зависимости от четности
