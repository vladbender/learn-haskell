
# Операторы

## Операторы и функции

Функции вызываются в префиксном стиле - название функции идет перед аргументами.
```haskell
max 5 4
```

Операторы вызываются в инфиксном стиле - оператор находится между своими аргументами.
```haskell
1 + 2
```

Это различие можно убрать. Для вызова функций в операторном стиле, нужно заключить ее в обратные кавычки `:
```haskell
5 `max` 4
```

И наоборот - операторы можно использовать как функции. Достаточно заключить их в круглые скобки ():
```haskell
(+) 1 2
```

Все операторы в Haskell - бинарные. Принимают два аргумента. За исключением унарного минуса. Из-за этого отрицательные числа приходится заключать в скобки.

## Приоритеты и ассоциативность операторов

Приоритет в Haskell - число от 0 до 9. Больше число - больше приоритет. Применение функции имеет приоритет 10. Поэтому в выражении `sin 5 + 4` сначала считается синус 5, а потом складывается с 4.

Операторы имеют левую или правую ассоциативность. Это значит расстановку скобок по умолчанию. Или сторону, с которой начинается вычисление. Например, оператор вычитания является левоассоциативным. И выражение `3 - 9 - 5` эквивалентно выражению `(3 - 9) - 5`.

Можно задать ассоциативность и приоритет своих операторов.
```haskell
infixl 7 <имя оператора>
```
В таком случае оператор будет левоассоциативен и с приоритетом 7. Для задания правоассоциативных операторов используется ключевое слово `infixr`. Если не требуется задавать ассоциативность операторов, то указывается ключевое слово `infix`. В таком случае запрещена цепочка выполнения операторов. Например `==` не имеет ассоциативности, из-за чего нельзя писать выражения вида `1 == 2 == 3`.

Пример операторов и их приоритетов из стандартной библиотеки:
```haskell
infixr 8 ^, `logBase`
infixl 7 *, /, `div`, `mod`
infixl 6 +, -
infix 4 ==, /=, >, >=, <, <=
```

Приоритет и ассоциативность по умолчанию - `infixl 9`.

## Задача 1

Попробуйте вычислить значение выражения 2 ^ 3 ^ 2, не используя GHCi.

**Ответ:** 512. Т.к. `^` имеет правую ассоциативность. И сначала вычисляется `3 ^ 2 = 9`, а затем `2 ^ 9 = 512`.

## Задача 2

Попробуйте вычислить значение выражения (*) 2 ((+) 1 4) ^ 2, не используя GHCi.

```haskell
(*) 2 ((+) 1 4) ^ 2
~> (*) 2 5 ^ 2
~> 10 ^ 2
~> 100
```

**Ответ:** 100. На 2м шаге сначала применяется умножение, а не возведение в степень, т.к. умножение используется как функция, а функции имеют наивысший приоритет.

## Реализация собственных операторов

В Haskell нет встроенных операторов. + * и т.д. заданы в стандартной библиотеке.

Можно задать свои операторы, используя символы:
```haskell
! # $ % & * + , / < = > ? @ \ ^ | - ~ :
```
Нельзя использовать уже используемые операторы (такие как +), но можно составлять операторы, состоящие из данных символов, например `*+*`. Двоеточие использовать не рекомендуется, причины этого будут затронуты далее.

Задание своего оператора:
```haskell
infixl 6 *+*
a *+* b = a ^ 2 + b ^ 2
```
Можно задавать и в функциональном стиле:
```haskell
(*+*) a b = a ^ 2 + b ^ 2
```

## Задача 3

Используя данное выше определение оператора (`*+*`), попробуйте устно вычислить значение выражения `1 + 3 *+* 2 * 2`.

```haskell
1 + 3 *+* 2 * 2
~> 4 *+* 2 * 2
~> 4 *+* 4
~> 32
```

**Ответ:** 32

## Задача 4

Реализуйте оператор |-|, который возвращает модуль разности переданных ему аргументов:
```haskell
GHCi>  5 |-| 7
2
```

**Ответ:**
```haskell
x |-| y = abs (x - y)
```

Код задачи можно загрузить [из файла](./task_1.3.4.hs).

## Сечение операторов

Есть так называемое сечение операторов для частичного их применения.

Левое сечение. Связывается левый аргумент для последующего частичного применения:
```haskell
*Main> (2 /) 4
0.5
```

Правое сечение. Связывается правый аргумент для последующего частичного применения:
```haskell
*Main> (/ 2) 4
2.0
```

Благодаря сечению можно задавать функции:
```haskell
*Main> let div10to = (10 /)
*Main> div10to 5
2.0
*Main> let divTo2 = (/ 2)
*Main> divTo2 24
12.0
```

Из-за существования унарного минуса нельзя сделать правое сечение оператора `-`.

## Задача 5

Попробуйте вычислить значение выражения (`mod` 14) ((+ 5) 10), не используя GHCi.
```haskell
(`mod` 14) ((+ 5) 10)
~> (`mod` 14) 15
~> 1
```

**Ответ:** 1

P.S. На втором шаге делится 15 на 14 т.к. тут правое сечение оператора `mod`.

## Оператор применения с низким приоритетом

В стандартной библиотеке языка Haskell определен такой оператор:
```haskell
f $ x = f x
```

У него самый низкий приоритет - 0. Это позволяет избавляться от избыточных скобок при вызове функций:
```haskell
*Main> sin (pi / 2)
1.0
*Main> sin $ pi / 2
1.0
```

У этого оператора правая ассоциативность. Поэтому такие записи эквивалентны:
```haskell
f (g x (h y)) = f $ g x $ h y
```

## Задача 6

Используя оператор $, перепишите выражение logBase 4 (min 20 (9 + 7)) без скобок.

**Ответ:**
```haskell
logBase 4 (min 20 (9 + 7)) = logBase 4 $ min 20 $ 9 + 7
```

Код задачи можно загрузить [из файла](./task_1.3.6.hs).