
# Локальные связывания и правила отступов

## Отступы

В Haskell отступы важны и распознаются компилятором. Они измеряются в пробелах, а табуляция считается равной 8 пробелам независимо от настроек редактора. Общие правила трансляции отступов сложны и описаны в стандарте.

Краткий принцип звучит так:
_Увеличение отступа - безопасно, а уменьшение отступа может привести к проблемам._

Увеличение отступа говорит о том, что мы продолжаем текущее объявление.

Пример расчета корней квадратного уравнения:
```
roots :: Double -> Double -> Double
          -> (Double, Double)
roots a b c =
  (
    (-b - sqrt (b ^ 2 - 4 * a * c)) / (2 * a)
  ,
    (-b + sqrt (b ^ 2 - 4 * a * c)) / (2 * a)
  )
```

## Выражение let...in...

Код функции `roots` содержит повторяющееся выражение - корень из дискриминанта. Можно связать подвыражение с локально определенным именем и дальше использовать его с помощью выражения `let ... in ...`:
```
roots a b c =
  let d = sqrt (b ^ 2 - 4 * a c)
  in ((-b - d) / (2 * a), (-b + d) / (2 * a))
```
После `let` идут локальные связывания выражений с переменными. Они могут использоваться во второй части после `in`. При этом результатом выражения `let in` является часть после `in`, например:
```
Prelude> let x = 5 in (x, "five")
(5,"five")
```

Можно задавать несколько связываний:
```
roots a b c =
  let { d = sqrt (b ^ 2 - 4 * a c); x1 = (-b - d) / (2 * a); x2 = (-b + d) / (2 * a) }
  in (x1, x2)
```
При этом порядок связываний не важен, более того, можно использовать рекурсивные связывания (не забыв позаботиться об окончании рекурсии).

В Haskell несколько объявлений можно писать в одну строчку, заключая их в `{}` и разделяя `;` как в примере выше.

Можно переписать пример с отступами:
```
roots a b c =
  let
    x1 = (-b - d) / aTwice
    x2 = (-b + d) / aTwice
    d = sqrt (b ^ 2 - 4 * a c)
    aTwice = 2 * a
  in (x1, x2)
```
При этом отступы в связываниях после let должны быть одинаковыми.

## Задача 1

Не используя GHCi, определите строку, которая является значением выражения `(let x = 'w' in [x,'o',x]) ++ "!"`.

**Ответ:** wow!

## Локальные связывания функций и образцов

С помощью `let in` можно определять локальные функции. Например факториал через `helper` можно определить внутри `let in`, чтобы функция `helper` не засоряла глобальное пространство имен:
```
factorial n
  | n >= 0 = let
      helper acc 0 = acc
      helper acc n = helper (acc * n) (n - 1)
    in helper 1 n
  | otherwise = error "arg must be >= 0"
```

Можно связывать с образцом:
```
rootsDiff a b c = let
  (x1, x2) = roots a b c
  in x2 - x1
```
Здесь мы знаем, что функция `roots` возвращает кортеж. И вместо того, чтобы определить результат как `x`, а потом взять `fsr x` и `snd x` мы можем написать `(x1, x2) = ...`.

## Задача 2

Реализуйте функцию seqA, находящую элементы следующей рекуррентной последовательности
```
a_0 = 1
a_1 = 2
a_2 = 3
a_{k+3} = a_{k+2} + a_{k+1} - 2 a_{k}
```
Попытайтесь найти эффективное решение.

GHCi> seqA 301
1276538859311178639666612897162414

**Ответ:**
```
seqA :: Integer -> Integer
seqA n =
  let
    helper first second third 0 = first
    helper first second third 1 = second
    helper first second third 2 = third
    helper first second third k =
      helper second third (third + second - 2 * first) (k - 1)
  in helper 1 2 3 n
```

Код задачи можно загрузить [из файла](./task_1.6.2.hs).

## Конструкция where

Помимо `let in` можно производить локальное связывание с помощью конструкции `where`. В нем сначала идет выражение с переменными, а уже после `where` идет локальное связывание. То есть наоборот, нежели в `let in`.

Пример с корнями:
```
roots a b c = (x1, x2) where
  x1 = (-b - d) / aTwice
  x2 = (-b + d) / aTwice
  d = sqrt (b ^ 2 - 4 * a c)
  aTwice = 2 * a
```

После `where` так же допускается использовать `{...;...}`.

Есть существенное различие. `let in` является выражением и его можно использовать внутри других выражений.

**`where` может использоваться только в определении функции и только в одном месте**. Это можно использовать в тех местах, где `let in` использовать нельзя. Например, при использовании общих функций внутри нескольких охранных выражений.

Пример с факториалом:
```
factorial n
    | n >= 0 = helper 1 n
    | otherwise = error "arg must be >= 0"
  where
    helper acc 0 = acc
    helper acc n = helper (acc * n) (n - 1)
```

## Задача 3

Реализуйте функцию, находящую сумму и количество цифр десятичной записи заданного целого числа.
```
sum'n'count :: Integer -> (Integer, Integer)
sum'n'count x = undefined

GHCi> sum'n'count (-39)
(12,2)
```

**Ответ:**
```
sum'n'count :: Integer -> (Integer, Integer)
sum'n'count x
    | x == 0 = (0, 1)
    | x < 0 = helper 0 0 (abs x)
    | otherwise = helper 0 0 x
  where
    helper sum count 0 = (sum, count)
    helper sum count num = helper (sum + mod num 10) (count + 1) (div num 10)
```

Код задачи можно загрузить [из файла](./task_1.6.3.hs).

## Задача 4

Реализуйте функцию, находящую значение определённого интеграла от заданной функции `f` на заданном интервале `[a,b]` методом трапеций. (Используйте равномерную сетку; достаточно 1000 элементарных отрезков.)

```
integration :: (Double -> Double) -> Double -> Double -> Double
integration f a b = undefined
GHCi> integration sin pi 0
-2.0
```

Результат может отличаться от -2.0, но не более чем на 1e-4.

**Ответ:**
```
integration :: (Double -> Double) -> Double -> Double -> Double
integration f a b
  | a == b = 0
  | b < a = - sum b (b - delta) 0 step (-delta)
  | otherwise = sum a (a + delta) 0 step delta
  where
    step = 1000
    delta = (b - a) / step
    sum x0 x1 result 0 delta = result
    sum x0 x1 result step delta =
      sum x1 (x1 + delta) (result + (f x0 + f x1) / 2 * (x1 - x0)) (step - 1) delta
```

Код задачи можно загрузить [из файла](./task_1.6.4.hs).