
# Нестрогая семантика

## Модели вычислений

В императивных языках порядок вычислений определяется последовательностью инструкций. В функциональных языках инструкций нет, вычисления в них происходят через редукцию выражений.

Редукцию тоже можно рассматривать с точки зрения порядка, например:
```haskell
sumIt :: Int -> Int -> Int
sumIt x y = x + y

Prelude> sumIt (1 + 2) 3
6
```

Введём функцию `sumIt` и попробуем её применить. В данном примере существует 2 возможные стратегии достижения результата: **энергичная** и **ленивая**.

В случае _энергичной_ стратегии сначала вычисляется `1 + 2`, затем результат передается в функцию `sumIt 3 3`:
```haskell
sumIt (1 + 2) 3
~> sumIt 3 3
~> 3 + 3
~> 6
```

В случае _ленивой_ стратегии можно сначала выполнить редукцию:
```haskell
sumIt (1 + 2) 3
~> (1 + 2) + 3
~> 3 + 3
~> 6
```

Введем термин: выражение, которое может быть упрощено непосредственно, носит название **redex** (от reducible expression).

В исходном выражении `sumIt (1 + 2) 3` два redex'a - сложение и применение функции. Когда в выражении несколько redex'ов, могут быть реализованы несколько стратегий вычисления.

В Haskell принята **ленивая** стратегия вычислений. В функциональных языках, независимо от выбранной стратегии, результат будет одним и тем жем. Это возможно благодаря чистоте функций.

## Задача 1

Предположим, что стандартные функции определены следующим образом:
```haskell
id x = x
const x y = x
max x y = if x <= y then y else x
infixr 0 $
f $ x = f x
```
Сколько редексов имеется в следующем выражении
```haskell
const $ const (4 + 5) $ max 42
```
_Примечание._ Мы определили шаг вычислений как подстановку тела функции вместо ее имени с заменой _всех_ ее формальных параметров на фактически переданные ей выражения. Редексом при этом мы называем подвыражение, над которым можно осуществить подобный шаг.

**Ответ:** 3

P.S. Важным замечанием является то, что редексом является функция, в которой можно заменить **все** формальные параметры. В данном случае max имеет один параметр - 4, это частично примененная функция. Аналогично с const. В итоге редексы тут - `$ $ +`.

## Свойства ленивой модели

Рассмотрим такую функцию:
```haskell
add7 :: Int -> Int -> Int
add7 x y = x + 7
```

В рамках ленивой модели вычисление идет так:
```haskell
add7 1 (2 + 3)
~> 1 + 7
~> 8
```
при этом второй параметр полностью игнорируется, более того - не вычисляется.

В рамках энергичной модели:
```haskell
add7 1 (2 + 3)
~> add7 1 5
~> 1 + 7
~> 8
```
т.е. производится лишнее вычисление.

В подобных случаях ленивая стратегия приводит к более эффективному вычислению. Однако, такое бывает не всегда.

Теперь рассмотрим такую функцию:
```haskell
dup :: Int -> (Int, Int)
dup x = (x, x)
```

Ленивая модель:
```haskell
dup (2+3)
~> (2+3,2+3)
~> (5,2+3)
~> (5,5)
```

Энергичная модель:
```haskell
dup (2+3)
~> dup 5
~> (5,5)
```

В рамках ленивой стратегии производятся лишние вычисления. Чтобы этого избежать, в Haskell есть **механизм разделения**. Вместо того, чтобы осуществлять синтаксическую подстановку при редукции, осуществляется подстановка по указателю. Он может ссылаться на отложеные вычисления, либо уже посчитанные значения. Таким образом редукции можно рассмотреть так:
```haskell
dup (2+3)
~> (p,p) p = 2+3
~> (5,5)
```

## Задача 2

Сколько шагов редукции потребуется, чтобы вычислить значение функции value, если используется ленивая стратегия вычислений с механизмом разделения?
```haskell
bar x y z = x + y
foo a b = bar a a (a + b)
value = foo (3 * 10) (5 - 2)
```
_Примечание._ Подстановку тела функции value вместо value не считайте.

Решение:
```haskell
foo (3 * 10) (5 - 2)
~> bar (3 * 10) (3 * 10) ((3 * 10) + (5 - 2))
~> (3 * 10) + (3 * 10)
~> 30 + 30
~> 60
```

**Ответ:** 4

## Строгие и нестрогие функции

Из-за ленивых вычислений возможна ситуация, когда функция содержит незавершающийся блок (например, бесконечную рекурсию), который будет отброшен из-за ленивости вычислений.
```haskell
const42 :: a -> Int
const42 = const 42
```
Эта функция является результатом частичного примения функции const, поэтому она будет возвращать 42, независимо от переданного значения:
```haskell
Prelude> const42 1
42
Prelude> const42 True
42
Prelude> const42 undefined
42
Prelude> const42 (error "hello")
42
```
такого рода функции называются нестрогими.

**Нестрогая функция** - это такая функция, в которую в качестве аргумента может быть передано расходящееся вычисление, но при этом результат сходится.

**Строгая функция** - это такая функция, которая расходится при расходящемся аргументе.

Функция нескольких аргументов может быть строгой или нестрогой по одному аргументу, в зависимости от значения другого. Поэтому анализ строгости или нестрогости - нетривиальная задача. Haskell умеет анализировать строгость и оптимизировать программы благодаря этому. Строгие функции могут быть заменены с ленивой модели на энергичную.


## Тест 1

Отметьте функции, которые не могут привести к расходимости ни на каком корректном наборе аргументов.

```haskell
foo a = a -- ТОЧНО РАЗОЙДЕТСЯ

bar = const foo -- МОЖЕТ РАЗОЙТИСЬ

baz x = const True -- не разойдется

quux = let x = x in x -- РАСХОДИТСЯ по умолчанию, рекурсивное определение

corge = "Sorry, my value was changed" -- не разойдется т.к. нет аргументов

grault x 0 = x -- РАЗОЙДЕТСЯ т.к. надо вычислять второй аргумент для понимания пути
grault x y = x

garply = grault 'q' -- соответственно РАЗОЙДЕТСЯ

waldo = foo  -- точно РАЗОЙДЕТСЯ т.к. копия foo
```

**Ответ:** `baz, corge`

## Слабая головная нормальная форма

Напомним, что вычисления в функциональных языках происходят с помощью редукции. Редукция происходит до тех пор, пока внутри редуцируемого выражения сохраняются редексы. Итоговое выражение редексов не содержит. Говорят, что такие выражения находятся в **нормальной форме**.

Примеры нормальных форм:
```haskell
42
(3, 4)
\x -> x + 2
```

Примеры выражений, которые не находятся в нормальной форме:
```haskell
"Real " ++ "world"
sin (pi / 2)
(\x -> x + 2) 5
(3, 1 + 5)
```
здесь мы можем продолжить редукции.

Существует также **слабая головная нормальная форма** (_WHNF - weak head normal form_). К ней относятся выражения, которые относятся к одному из следующих видов:
- Любая лямбда абстракция: `\x -> x + 2*3`
- Любой конструктор данных: `(3, 1+5)` или `[1,2+3]`
- Частично примененный конструктор данных: `(,) (4*5)`
- Частично примененная **встроенная** функция: `(+) (7^2)`

Понятие слабой головной нормальной форме расширяет понятие нормальной формы, поэтому все выражения, находящиеся в нормальной форме, находятся также и в слабой головной нормальной форме. Во многих ситуациях вычисления в Haskell заканчиваются в слабой головной нормальной форме.

## Тест 2

Какие из выражений ниже не находятся в нормальной форме, но находятся в слабой головной нормальной форме?

**Ответ:**
- [x] (+) (2 * 3 * 4)
- [ ] 3
- [x] [undefined, 4 + 5, -1]
- [ ] fst (1,0)
- [x] (,) undefined
- [ ] \x -> x

## Форсирование вычислений

Механизм ленивых вычислений очень удобен - когда выражение не требуется для получения результата вычисления, оно и не будет вычисляться. Однако могут возникнуть проблемы. Например, при обработке списка большой длины отложенные вычисления могут накапливаться (допустим, мы хотим сложить его элементы). Такая цепочка вычислений может занимать очень много места в памяти. Такое хаскеллисты называют **утечками памяти**, т.е. необоснованный рост памяти для совершения вычислений.

Есть оператор **`seq`**, используемый для нарушения ленивого механизма вычислений. Определен он подобным образом:
```haskell
seq :: a -> b -> b
seq _|_ b = _|_
seq a b = b
```

Этот оператор является вычислительным примитивом, его нельзя самому задать средствами хаскелля. Он возвращает свой второй аргумент, игнорируя первый. Запись `seq _|_ b = _|_` содержит основание (`_|_`) и означает, что если первый аргумент расходится, то и все выражение должно расходиться. Если первый аргумент вычисляется до значения, то возвращается второй аргумент.

`seq` _форсирует_ вычисление своего первого аргумента и, если оно сходится, возвращает второй.

Примеры:
```haskell
Prelude> seq 1 2
2
Prelude> seq undefined 2
*** Exception: Prelude.undefined
CallStack (from HasCallStack):
  error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err
  undefined, called at <interactive>:29:5 in interactive:Ghci17
Prelude> seq (id undefined) 2
*** Exception: Prelude.undefined
CallStack (from HasCallStack):
  error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err
  undefined, called at <interactive>:31:9 in interactive:Ghci18
```

**`seq` форсирует вычисление своего первого аргумента до _слабой заголовочной нормальной формы_**:
```haskell
Prelude> seq (undefined, undefined) 2
2
Prelude> seq [undefined, undefined] 2
2
Prelude> seq (\x -> undefined) 2
2
```

## Тест 3

При вычислении каких из перечисленных ниже функций использование seq предотвратит нарастание количества невычисленных редексов при увеличении значения первого аргумента:
```haskell
foo 0 x = x
foo n x = let x' = foo (n - 1) (x + 1)
          in x' `seq` x'

bar 0 f = f
bar x f = let f' = \a -> f (x + a)
              x' = x - 1
          in f' `seq` x' `seq` bar x' f'

baz 0 (x, y) = x + y
baz n (x, y) = let x' = x + 1
                   y' = y - 1
                   p  = (x', y')
                   n' = n - 1
               in p `seq` n' `seq` baz n' p

quux 0 (x, y) = x + y
quux n (x, y) = let x' = x + 1
                    y' = y - 1
                    p  = (x', y')
                    n' = n - 1
                in x' `seq` y' `seq` n' `seq` quux n' p
```

**Ответ:**
- [ ] foo
- [ ] bar
- [ ] baz
- [x] quux

P.S.

В функции `foo` происходит накопление при вызове функции: `foo ((((n - 1) - 1) - 1 )...- 1) ((((x + 1) + 1) + 1 )...+ 1)`.

В `bar` копится в лямбде, т.к. она является `WHNF`.

В `baz` копится в переменной `p` т.к. она содержит кортеж, который является `WHNF`.

P.P.S. `seq` не заставляет первый аргумент вычисляться в любом случае. Он вычисляется только если от него зависит второй аргумент. Поэтому запись `seq x x` эквивалентна `x`. Поэтому `foo` не оптимизируется.

## Аппликация с вызовом по значению

Использовать `seq` не очень удобно. Поэтому в Haskell определен оператор аппликации с вызовом по значению, с помощью которого можно форсировать вычисления:
```haskell
($!) :: (a -> b) -> a -> b
f $! x = x `seq` f x
```

Этот оператор похож на оператор `$`, только при этом аргумент функции передается в seq и вычисляется до слабой заголовочной нормальной формы.

```haskell
Prelude> :i ($!)
($!) :: (a -> b) -> a -> b      -- Defined in ‘GHC.Base’
infixr 0 $!
Prelude> const 42 undefined
42
Prelude> const 42 $ undefined
42
Prelude> const 42 $! undefined
*** Exception: Prelude.undefined
CallStack (from HasCallStack):
  error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err
  undefined, called at <interactive>:3:13 in interactive:Ghci2
```

Пример, в котором могут накопиться вычисления:
```haskell
factorial :: Integer -> Integer
factorial n | n >= 0 = helper 1 n
            | otherwise = undefined
  where
    helper acc 0 = acc
    helper acc n = helper (acc * n) (n - 1)
```
в строке `helper acc n = helper (acc * n) (n - 1)` происходит накопление умножений и вычитаний. Чтобы избежать накопления умножений, можно форсировать вычисления:
```haskell
factorial n | n >= 0 = helper 1 n
            | otherwise = undefined
  where
    helper acc 0 = acc
    helper acc n = (helper $! (acc * n)) (n - 1)
```

Стоит заметить, что в данном случае оптимизатор Haskell скорее всего справится сам. Это лишь пример, на котором просто показать как такие вычисления можно форсировать.

## Тест 4

Ниже определены функции mySum и goSum. Вызов goSum может выглядеть, к примеру, так:  goSum 15. Выберите верные утверждения, описывающие процесс вычисления подобного выражения.
```
mySum acc 0 = acc
mySum (result, ()) n = (mySum $! (result + n, ())) $ n - 1

goSum = mySum (0, ())
```

**Ответ:**

- [ ] В первом аргументе функции mySum не будут накапливаться отложенные вычисления, так как при рекурсивных вызовах используется оператор $!.
- [ ] В первом аргументе функции mySum не будут накапливаться отложенные вычисления, так как он будет находиться в слабой головной нормальной форме.
- [x] В первом аргументе функции mySum будут накапливаться отложенные вычисления.
- [ ] Во втором аргументе функции mySum будут накапливаться отложенные вычисления из-за того, что его передача при рекурсивном вызове происходит с помощью оператора $ а не $!.
- [x] Во втором аргументе функции mySum не будут накапливаться отложенные вычисления, так как при каждом рекурсивном вызове происходит сопоставление с 0.
- [ ] Во втором аргументе функции mySum не будут накапливаться отложенные вычисления, так как минус - примитивная операция.