
# Классы типов

## Контексты

Поговорим про функции, которые реализуют специальный полиморфизм. Функция может вызываться на разных типах данных, но каждый тип данных должен обеспечивать реализацию соответствующего интерфейса. Такой интерфейс в Haskell называется **классом типов**.

Существующие классы типов отражаются в текущих функциях так:
```
Prelude> :t 7
7 :: Num p => p
```
В записи `Num p => p` есть символ `=>`. Он разделяет тип на две части. Правая - непосредственно тип выражения. Левая - контекст. Контекст состоит из двух частей: имя интерфейса типа и тип, к которому он применен.

В данном примере `7` имеет полиморфный тип `a`, но для этого типа `a` выставлен интерфейс `Num`.

Интерфейс `Num` выставляет целый ряд функций, например `+`, `*`, `-` и т.д. Например:
```
Prelude> :t (+)
(+) :: Num a => a -> a -> a
```

Есть другие интерфейсы, помимо `Num`:
```
Prelude> :t (>)
(>) :: Ord a => a -> a -> Bool
```
Оператор больше принимает два аргумента типа `a` и возвращает `Bool`. На аргументы наложено ограничение `Ord`.

Если составить сечение оператора `(>)` числом `7`:
```
Prelude> :t (> 7)
(> 7) :: (Ord a, Num a) => a -> Bool
```
То контекст становится сложнее - на аргумент `a` наложено два ограничения - `Ord` и `Num`.

`Ord` и `Num` - разные классы типов, например комплексные числа являются представителям `Num`, но не `Ord`.

Более сложный пример с кортежами:
```
Prelude> :t (> (1,2))
(> (1,2)) :: (Ord a, Ord b, Num a, Num b) => (a, b) -> Bool
```
Оба элемента пары могут быть разных типов, но оба должны принадлежать к классам `Num` и `Ord`.

## Задача 1

На нехватку какого представителя какого класса типов пожалуется интерпретатор при попытке вывести тип выражения
```
True + False * False
```
Запишите ответ в виде Имя_класса_типов Имя_типа. Постарайтесь ответить, не используя GHCi.

**Ответ:** `Num Bool`

## Объявление класса типов

Класс типов представляет собой именованный набор имен функций с сигнатурами, параметризованный общим типовым параметром. Задается так:
```
class Eq a where
  (==) :: a -> a -> Bool
  (/=) :: a -> a -> Bool
```
Здесь не задается реализация, а лишь интерфейс. Реализацию должен предоставить каждый конкретный тип.

Класс типов `Eq` существует в стандартной библиотеке.

Если иследовать операторы из этого класса в интерпретаторе, то мы увидим такое же определение, как и в классе типов с указанием контекста:
```
Prelude> :t (==)
(==) :: Eq a => a -> a -> Bool
Prelude> :t (/=)
(/=) :: Eq a => a -> a -> Bool
```

Если функция остается полиморфной, то контекст сохраняется:
```
Prelude> :t (== 13)
(== 13) :: (Eq a, Num a) => a -> Bool
```

Если совсем конкретизировать тип, то контекст пропадет:
```
Prelude> :t (== 'a')
(== 'a') :: Char -> Bool
```

## Задача 2

Попробуйте, не используя GHCi или Hoogle, определить, какого контекста не хватает в типе функции
```
sort :: ? => [d] -> [d]
```
сортирующей переданный в нее список. Напишите выражение, которое должно стоять на месте знака вопроса.

**Ответ:** `Ord d`

## Объявление представителей класса типов



## Задача 3
## Полиморфизм при объявлении представителей
## Задача 4