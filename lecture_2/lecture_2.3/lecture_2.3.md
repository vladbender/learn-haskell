
# Классы типов

## Контексты

Поговорим про функции, которые реализуют специальный полиморфизм. Функция может вызываться на разных типах данных, но каждый тип данных должен обеспечивать реализацию соответствующего интерфейса. Такой интерфейс в Haskell называется **классом типов**.

Существующие классы типов отражаются в текущих функциях так:
```haskell
Prelude> :t 7
7 :: Num p => p
```
В записи `Num p => p` есть символ `=>`. Он разделяет тип на две части. Правая - непосредственно тип выражения. Левая - контекст. Контекст состоит из двух частей: имя интерфейса типа и тип, к которому он применен.

В данном примере `7` имеет полиморфный тип `a`, но для этого типа `a` выставлен интерфейс `Num`.

Интерфейс `Num` выставляет целый ряд функций, например `+`, `*`, `-` и т.д. Например:
```haskell
Prelude> :t (+)
(+) :: Num a => a -> a -> a
```

Есть другие интерфейсы, помимо `Num`:
```haskell
Prelude> :t (>)
(>) :: Ord a => a -> a -> Bool
```
Оператор больше принимает два аргумента типа `a` и возвращает `Bool`. На аргументы наложено ограничение `Ord`.

Если составить сечение оператора `(>)` числом `7`:
```haskell
Prelude> :t (> 7)
(> 7) :: (Ord a, Num a) => a -> Bool
```
То контекст становится сложнее - на аргумент `a` наложено два ограничения - `Ord` и `Num`.

`Ord` и `Num` - разные классы типов, например комплексные числа являются представителям `Num`, но не `Ord`.

Более сложный пример с кортежами:
```haskell
Prelude> :t (> (1,2))
(> (1,2)) :: (Ord a, Ord b, Num a, Num b) => (a, b) -> Bool
```
Оба элемента пары могут быть разных типов, но оба должны принадлежать к классам `Num` и `Ord`.

## Задача 1

На нехватку какого представителя какого класса типов пожалуется интерпретатор при попытке вывести тип выражения
```haskell
True + False * False
```
Запишите ответ в виде Имя_класса_типов Имя_типа. Постарайтесь ответить, не используя GHCi.

**Ответ:** `Num Bool`

## Объявление класса типов

Класс типов представляет собой именованный набор имен функций с сигнатурами, параметризованный общим типовым параметром. Задается так:
```haskell
class Eq a where
  (==) :: a -> a -> Bool
  (/=) :: a -> a -> Bool
```
Здесь не задается реализация, а лишь интерфейс. Реализацию должен предоставить каждый конкретный тип.

Если функции имеют одинаковые сигнатуры, можно их перечислить через запятую:
```haskell
class Eq a where
  (==), (/=) :: a -> a -> Bool
```

Класс типов `Eq` существует в стандартной библиотеке.

Если иследовать операторы из этого класса в интерпретаторе, то мы увидим такое же определение, как и в классе типов с указанием контекста:
```haskell
Prelude> :t (==)
(==) :: Eq a => a -> a -> Bool
Prelude> :t (/=)
(/=) :: Eq a => a -> a -> Bool
```

Если функция остается полиморфной, то контекст сохраняется:
```haskell
Prelude> :t (== 13)
(== 13) :: (Eq a, Num a) => a -> Bool
```

Если совсем конкретизировать тип, то контекст пропадет:
```haskell
Prelude> :t (== 'a')
(== 'a') :: Char -> Bool
```

## Задача 2

Попробуйте, не используя GHCi или Hoogle, определить, какого контекста не хватает в типе функции
```haskell
sort :: ? => [d] -> [d]
```
сортирующей переданный в нее список. Напишите выражение, которое должно стоять на месте знака вопроса.

**Ответ:** `Ord d`

## Объявление представителей класса типов

Конкретный тип является _представителем_ класса типов, если для него реализованы все функции, которые в классе типов объявлены. Иногда вместо _представитель_ используют слово _экземпляр_ (с английского instance).

Пример реализации представителя класса типов:
```haskell
class Eq a where
  (==), (/=) :: a -> a -> Bool

instance Eq Bool where
  True  == True  = True
  False == False = True
  _     == _     = False

  x /= y = not (x == y)
```
Отступы после `where` обязательны.

Первая функция `(==)` реализована через сопоставление с образцом. Также используется специальный символ `_`, который обозначает сопоставление во всех остальных случаях - сопоставление с таким образцом всегда верно.

Вторая функция `(/=)` реализована через первую функцию.

В Haskell объявление класса типов и объявление приналежания конкретного типа к классу разнесено. Благодаря этому, мы можем сделать любой тип принадлежащим любому классу типов.

В классе типов могут быть реализованы методы по умолчанию:
```haskell
class Eq a where
  (==), (/=) :: a -> a -> Bool
  x /= y = not (x == y)
```
В таком случае представителям достаточно реализовать лишь `(==)`. Представитель может перекрывать реализацию по умолчанию, если она его не устраивает.

Более того, мы можем давать циклические реализации по умолчанию:
```haskell
class Eq a where
  (==), (/=) :: a -> a -> Bool
  x /= y = not (x == y)
  x == y = not (x /= y)
```
В таком случае мы можем реализовать любую удобную нам функцию, а вторая будет реализацией по умолчанию.

В документации по Haskell есть термин **Minimal Complete Definition** (минимальное полное определение) - что в классе типов необходимо реализовать, остальное же может быть реализовано по умолчанию. Может быть такое, что класс типов имеет все реализации по умолчанию. Тогда мы можем просто написать `instance Class Type where`. Надо лишь быть внимательным, не являются ли реализации по умолчанию цикличными. Такое обычно указывается в документации.

## Задача 3

Реализуйте класс типов `Printable`, предоставляющий один метод `toString` — функцию одной переменной, которая преобразует значение типа, являющегося представителем `Printable`, в строковое представление.

Сделайте типы данных `Bool` и `()` представителями этого класса типов, обеспечив следующее поведение:
```haskell
GHCi> toString True
"true"
GHCi> toString False
"false"
GHCi> toString ()
"unit type"
```

**Ответ:**
```haskell
class Printable a where
  toString :: a -> String

instance Printable () where
  toString () = "unit type"

instance Printable Bool where
  toString True = "true"
  toString False = "false"
```

Код задачи можно загрузить [из файла](./task_2.3.3.hs).

## Полиморфизм при объявлении представителей

Представителем класса типов можно объявлять не только конкретный тип, но и полиморфный тип. Например, равенство пар (кортежей из двух элементов):
```haskell
instance (Eq a, Eq b) => Eq (a, b) where
  p1 == p2 = fst p1 == fst p2 && snd p1 == snd p2
```
Здесь в объявлении представителя появляется контекст `(Eq a, Eq b)`, который говорит о том, что пара является представителем класса типов `Eq` только в случае когда каждый её элемент является представителем класса `Eq`.

В стандартной библиотеке пара и так является представителем класса `Eq`, поэтому нам нет необходимости загружать подобный код.

## Задача 4

Сделайте тип пары представителем класса типов `Printable`, реализованного вами в предыдущей задаче, обеспечив следующее поведение:
```haskell
GHCi> toString (False,())
"(false,unit type)"
GHCi> toString (True,False)
"(true,false)"
```
**Примечание.** Объявление класса типов `Printable` и представителей этого класса для типов `()` и  `Bool` заново реализовывать не надо — они присутствуют в программе, вызывающей ваш код.

**Ответ:**
```haskell
instance (Printable a, Printable b) => Printable (a,b) where
  toString p = "(" ++ toString (fst p) ++ "," ++ toString (snd p) ++ ")"
```

Код задачи можно загрузить [из файла](./task_2.3.4.hs).
