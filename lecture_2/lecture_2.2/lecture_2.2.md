
# Параметрический полиморфизм (2)

## Оператор композиции функций

Пусть `f`, `g` - две полиморфные функции. Мы хотим описать оператор композиции этих функций. То есть такую функцию, которая принимает две функции - `f` и `g` - и возвращает функцию, которая принимает некую переменную `x`, сначала применяет к ней функцию `g`, а потом к результату применяет функцию `f`.

Со стороны типов это может выглядеть так:
```
f :: b -> c
g :: a -> b
x :: a
```
Т.к. мы хотим применять функцию `f` к результату функции `g`, то функция `g` должна возвращать значение, принимаемое на вход функцией `f`. В данном случае - это переменная типа `b`. При этом переменная `x` должна иметь тип, принимаемый функцией `g`.

Последовательное применение функций выглядит так:
```
f (g x) :: c
```
Чтобы построить функцию композиции, мы можем абстрагироваться по `x` через лямбда выражение:
```
\x -> f (g x) :: a -> c
```
Это выражение описывает композицию функций `f` и `g`. Осталось передать сами функции `f` и `g`:
```
Prelude> compose f g = \x -> f (g x)
Prelude> :t compose
compose :: (t1 -> t2) -> (t3 -> t1) -> t3 -> t2
```
Судя по типам функции `compose` мы получили ровно то, что и хотели.

В Haskell есть оператор композиции функций, определенный точно так же, как и наша функция `compose` - это оператор `(.)`:
```
Prelude> :i (.)
(.) :: (b -> c) -> (a -> b) -> a -> c   -- Defined in ‘GHC.Base’
infixr 9 .
```
Здесь мы видим, что приоритет оператора композиции функций - 9, а его ассоциативность - правая.

Пример использования оператора композиции:

В прошлой лекции мы объявили функцию `sumFstFst`, которая принимает две пары пар и возвращает сумму первых элементов первых пар этих пар пар:
```
Prelude> let p1 = ((1,2),(3,4))
Prelude> let p2 = ((3,4),(5,6))
Prelude> import Data.Function
Prelude Data.Function> sumFstFst = on (+) (\pp -> fst $ fst pp)
Prelude Data.Function> sumFstFst p1 p2
4
```
Можно объявить эту функцию через композицию:
```
sumFstFst = on (+) (fst . fst)
```

Можно строить последовательную композицию функций:
```
f (g (h x)) ~ f . g . h
```

## Задача 1

Функция одной переменной `doItYourself` выбирает наибольшее из переданного ей аргумента и числа 42, затем возводит результат выбора в куб и, наконец, вычисляет логарифм по основанию 2 от полученного числа. Эта функция реализована в виде:
```
doItYourself = f . g . h
```
Напишите реализации функций f, g и h. Постарайтесь сделать это в бесточечном стиле.
```
f = undefined

g = undefined

h = undefined
```

**Ответ:**
```
doItYourself = f . g . h

f = \z -> logBase 2 z

g = \y -> y ^ 3

h = \x -> max x 42
```

Код задачи можно загрузить [из файла](./task_2.2.1.hs).

P.S. Посмотрев другие решения, понял, что можно было бы через частичное применение функций:
```
f = logBase 2
g = (^3)
h = max 42
```

## Полиморфизм кортежей и списков

Списки и кортежи тоже параметрически полиморфны.

В качестве элементов списка можно использовать любой тип. Тип пустого списка содержит переменную типа:
```
Prelude> :t []
[] :: [a]
```

Этот полиморфизм виден в операторах над списками:
```
Prelude> :t (++)
(++) :: [a] -> [a] -> [a]
Prelude> :t (:)
(:) :: a -> [a] -> [a]
```

С кортежами есть альтернативный способ конструирования кортежей:
```
Prelude> ("one", 2)
("one",2)
Prelude> (,) "one" 2
("one",2)
Prelude> :t (,)
(,) :: a -> b -> (a, b)
```

Такой стиль конструирования кортежей `(,) "one" 2` называется **естественно префиксным стилем**. Стиль используемый до этого `("one", 2)` называется **миксфиксным стилем**.

Таким образом можно конструировать кортежи больших размерностей:
```
Prelude> :t ("one", 2, 3.0)
("one", 2, 3.0) :: (Fractional c, Num b) => ([Char], b, c)
Prelude> (,,) "one" 2 3.0
("one",2,3.0)
Prelude> :t (,,)
(,,) :: a -> b -> c -> (a, b, c)
```

Или даже:
```
Prelude> :t (,,,,,)
(,,,,,) :: a -> b -> c -> d -> e -> f -> (a, b, c, d, e, f)
```

Можно уменьшить степень полиморфизма, но не убрать её совсем. Определим функцию:
```
Prelude> dup x = (x,x)
Prelude> :t dup
dup :: b -> (b, b)
```
Такая функция все еще полиморфна, но при этому возвращает кортеж из 2-х элементов, но с некоторым ограничением - оба элемента будут одного типа.

Функции работы с кортежами также полиморфны:
```
Prelude> :t fst
fst :: (a, b) -> a
Prelude> :t snd
snd :: (a, b) -> b
```

## Задача 2

Сколько разных всегда завершающихся функций с типом a -> (a,b) -> a -> (b,a,a) можно реализовать?

**Ответ:** `9`

P.S. Необходимо вернуть кортеж из 3-х элементов. Первый типа `b`, второй и третий типа `a`. Т.к. тут используются переменные типа без всяких ограничений, то мы можем лишь возвращать переданные нам значения. В качестве первого элемента мы можем взять единственное значение - второй элемент второй переменной функции. В качестве второго элемента у нас 3 варианта - первая переменная, первый элемент второй переменной и третья переменная. Для 3-го элемента результата аналогично. При этом 2-й и 3-й элемент результата независимы. Получается 3*3 = 9.

## Каррирование

Идея частичного применения функции, когда в функцию передаются не все аргументы и на выходе получаем тоже функцию, придумана Хаскеллом Карри. Такие функции называют **каррированными**.

При этом в Haskell не все функции являются каррированными. Например, функцию над кортежем из двух элементов можно рассматривать как функцию 2-х аргументов. При вызове функции над кортежем синтаксис вызова функции похож на другие языки - со скобками и запятой. Такие функции можно назвать некаррированными:
```
Prelude> fst ("one", "two")
"one"
```

Встает проблема - как переходить от каррированных функций к некаррированным и наоборот?

Переход от некаррированных функций к каррированным называют **каррированием**.

Функцию `fst` можно считать некаррированой. Мы не можем передавать ее как аргумент в те функции, которые принимают фунцию двух аргументов. Например, в `on`:
```
Prelude Data.Function> :t fst `on` (^2)

<interactive>:1:1: error:
• Occurs check: cannot construct the infinite type:
    b ~ (b -> c, b0)
  Expected type: b -> b -> c
    Actual type: (b -> c, b0) -> b -> c
• In the first argument of ‘on’, namely ‘fst’
  In the expression: fst `on` (^ 2)
```

В языке Haskell есть функция **`curry`**, которая каррирует переданную ей функцию:
```
Prelude Data.Function> :t curry fst `on` (^2)
curry fst `on` (^2) :: Num c => c -> c -> c
```

Как устроена функция `curry`? Попытаемся ее сконструировать:
```
Prelude Data.Function> cur f x y = f (x, y)
Prelude Data.Function> cur fst 1 2
1
Prelude Data.Function> :t cur
cur :: ((a, b) -> t) -> a -> b -> t
Prelude Data.Function> :t curry
curry :: ((a, b) -> c) -> a -> b -> c
```

Как мы видим, тип сконструированной нами функции `cur` совпадает с типом функции `curry`.

Есть и обратная функция **`uncarry`**, которая принимает каррированную функцию и возвращает некаррированную:
```
Prelude Data.Function> :t uncurry
uncurry :: (a -> b -> c) -> (a, b) -> c
Prelude Data.Function> s x y = x + y
Prelude Data.Function> (uncurry s) (1, 2)
3
```

## Задача 3

Какому известному вам библиотечному оператору, конструктору или функции эквивалентно выражение `curry id`?

**Ответ:** `(,)`

P.S. Достаточно посмотреть результат выполнения:
```
Prelude Data.Function> curry id 2 3
(2,3)
```

## Задача 4

Какому известному вам библиотечному оператору, конструктору или функции эквивалентно выражение `uncurry (flip const)`?

**Ответ:** `snd`

## Задача 5

В модуле `Data.Tuple` стандартной библиотеки определена функция `swap :: (a,b) -> (b,a)`, переставляющая местами элементы пары:
```
GHCi> swap (1,'A')
('A',1)
```
Эта функция может быть выражена в виде:
```
swap = f (g h)
```
где `f`, `g` и `h` — некоторые идентификаторы из следующего набора:
```
curry uncurry flip (,) const
```
Укажите через запятую подходящую тройку `f`,`g`,`h`.

**Ответ:** `uncurry,flip,(,)`

P.S. Можно прийти к ответу поигравшись в интерпретаторе:
```
Prelude> (,) 1 2
(1,2)
Prelude> flip (,) 1 2
(2,1)
Prelude> uncurry (flip (,)) (1, 2)
(2,1)
```