
# Параметрический полиморфизм

## Полиморфные функции

Про функцию говорят, что она обладает полиморфным поведением, если она может быть вызвана на значениях разных типов. Например, `(+)`.

2 типа полиморфизма:
- параметрический - код функций одинаков для всех типов, на которых она может быть вызвана
- специальный - для каждого типа имеется своя реализация

Пример параметрически полиморфных функций:
```
Prelude> let id x = x
Prelude> :t id
id :: p -> p
```
Тут тип `p` с маленькой буквы. Это означает, что тип может быть произволен. Используется _переменная_ типа. Вместо неё может быть любой тип.

Функция `id` - часть стандартной библиотеки.

Ещё пример:
```
Prelude> let k x y = x
Prelude> k 42 "hello"
42
Prelude> :t k
k :: p1 -> p2 -> p1
```
Эта функция возвращает первый аргумент, полностью игнорируя второй.

Такая функция есть в стандартной библиотеке, но называется она `const`.
```
Prelude> const 1 2
1
```

К слову об `undefined` и `error`:
```
Prelude> :t undefined
undefined :: a
Prelude> :t error
error :: [Char] -> a
```
Поэтому они могут использоваться в любом выражении.

## Задача 1

Напишите функцию трех аргументов getSecondFrom, полиморфную по каждому из них, которая полностью игнорирует первый и третий аргумент, а возвращает второй. Укажите ее тип.
```
GHCi> getSecondFrom True 'x' "Hello"
'x'
GHCi> getSecondFrom 'x' 42 True 
42
```

**Ответ:**
```
getSecondFrom :: a -> b -> c -> b
getSecondFrom a b c = b
```

Код задачи можно загрузить [из файла](./task_2.1.1.hs).

## Задача 2

Сколько разных всегда завершающихся функций с типом a -> a -> b -> a -> a можно реализовать?

Две функции одинаковой арности считаются разными, если существует набор значений их аргументов, на котором они дают разные результирующие значения.

**Ответ:** 3

P.S. Так как тип указан наиболее общим способом, значит с переменными одного типа нельзя совершать никаких операций. Остается лишь вариант реализации функции как возврат одной из переменных. Поэтому, каждая из этих функций может возвращать либо 1, либо 2, либо 4й аргумент в качестве своего значения.

## Наиболее общий тип

Можно ограничить выводимый Хаскеллем тип вручную:
```
mono :: Char -> Char
mono x = x
```
Она аналогична функции `id`, но может быть вызвана только на переменных типа `Char`.

Можно частично ограничивать полиморфизм:
```
semiMono :: Char -> a -> Char
semiMono x y = x
```

Если не указывать тип явно, то Haskell выводит **наиболее общий тип**. В процессе вывода типов Haskell строит систему уравнений. Дальше он её разрешает, но разрешает наиболее общим способом. Он это делает по алгоритму [Хиндли - Дамаса - Милнера](https://ru.wikipedia.org/wiki/%D0%92%D1%8B%D0%B2%D0%BE%D0%B4_%D1%82%D0%B8%D0%BF%D0%BE%D0%B2#%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%A5%D0%B8%D0%BD%D0%B4%D0%BB%D0%B8_%E2%80%94_%D0%9C%D0%B8%D0%BB%D0%BD%D0%B5%D1%80%D0%B0).

## Функции высших порядков

Функцией высшего порядка называется такая функция, которая в качестве аргумента принимает другую функцию.

Например, оператор `($)` является функцией высшего порядка.
```
Prelude> :t ($)
($) :: (a -> b) -> a -> b
```

Пример из стандартной библиотеки, которая переставляет местами параметры функции:
```
Prelude> (/) 4 2
2.0
Prelude> flip (/) 4 2
0.5
Prelude> const 1 2
1
Prelude> flip const 1 2
2
Prelude> :t flip
flip :: (a -> b -> c) -> b -> a -> c
Prelude> :t (flip const)
(flip const) :: b -> c -> c
```

## Задача 3

В модуле Data.Function определена полезная функция высшего порядка
```
on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
on op f x y = f x `op` f y
```
Она принимает четыре аргумента: бинарный оператор с однотипными аргументами (типа b), функцию `f :: a -> b`, возвращающую значение типа b, и два значения типа a. Функция on применяет f дважды к двум значениям типа a и передает результат в бинарный оператор.

Используя on можно, например, записать функцию суммирования квадратов аргументов так:
```
sumSquares = (+) `on` (^2)
```
Функция multSecond, перемножающая вторые элементы пар, реализована следующим образом
```
multSecond = g `on` h

g = undefined

h = undefined
```
Напишите реализацию функций g и h.
```
GHCi> multSecond ('A',2) ('E',7)
14
```

**Ответ:**
```
import Data.Function

multSecond = g `on` h
g = (*)
h = snd
```

Код задачи можно загрузить [из файла](./task_2.1.3.hs).

## Анонимные функции — лямбда

Анонимные функции (или лямбда функции) - это функции без имени. Используются, например, в тех случаях, когда надо передать одну функцию в другую функцию, но при этом не хочется задавать отдельно (или через where) первую функцию.

Лямбда выражение:
```
Prelude> (\x -> 2 * x + 7) 10
27
```
Здесь `\` обозначает лямбда функцию.

Можно определять функции через лямбда выражения:
```
f = \x -> 2 * x + 7
```

Можно задавать функции нескольких аргументов:
```
f x y = x + y
f x = \y -> x + y
f = \x -> \y -> x + y
f = \x y -> x + y
```

Это всё идентичные записи, причем в последней строчке - синтаксический сахар.

Ещё пример работы с лямбдами:
```
Prelude> let p1 = ((1,2),(3,4))
Prelude> let p2 = ((3,4),(5,6))
Prelude> import Data.Function
Prelude Data.Function> sumFstFst = on (+) (\pp -> fst $ fst pp)
Prelude Data.Function> sumFstFst p1 p2
4
```

## Задача 4

Реализуйте функцию on3, имеющую семантику, схожую с on, но принимающую в качестве первого аргумента трехместную функцию:
```
on3 :: (b -> b -> b -> c) -> (a -> b) -> a -> a -> a -> c
on3 op f x y z = undefined
```
Например, сумма квадратов трех чисел может быть записана с использованием on3 так
```
GHCi> let sum3squares = (\x y z -> x+y+z) `on3` (^2)
GHCi> sum3squares 1 2 3
14
```

**Ответ:**
```
on3 :: (b -> b -> b -> c) -> (a -> b) -> a -> a -> a -> c
on3 op f x y z = op (f x) (f y) (f z)
```

Код задачи можно загрузить [из файла](./task_2.1.4.hs).